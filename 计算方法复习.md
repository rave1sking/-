# 0x00 python 的一些用法：

### 1、e的表示:

```python
import numpy as np
np.e      
np.exp() #表示e的几次方
```

### 2、一些输入：

```python
a,b,d=map(float,input().split())
```

### 3、构造等分数列

```python
x = np.linspace(a, b, 9)   # 构造一个8等分数列 以a,b为起点和终点
```

### 4、输出

```python
print('%.3f' % i)
print("{:.8f}".format(s))
#矩阵的倒序输出
print(C[::-1])
```

### 5、矩阵操作

```python
#n行n列矩阵
a = np.zeros((n,n) ,dtype = np.double) #（n,n)表示n行n列，dtype代表数据类型为double型，初始化为0
for r in range(n):
   a[r,:] = np.array(input().split(),dtype = np.double) #输入第0~n-1行，用空格隔开
#n行1列矩阵
b = np.zeros((n,1),dtype = np.double) #声明为n行1列double型，初始化为0
for  r in range(n):
  b[r] = np.array(input(),dtype = np.double)
Matr = np.hstack((a, b)) #构建增广矩阵
#行*列
x[k] = a[k, k+1:n] @ x[k+1:n]
# 也可用于矩阵直接相乘

#矩阵换行
Matr[[i,c],:] = Matr[[c,i],:]     #第i行和第c行互换
#整行操作
Matr[j,0:n+1] -= m*Matr[i,0:n+1] #注意:的灵活运用
#构造一个n行E矩阵
P  = np.identity(n)
#矩阵赋值
p = X.copy()
#欧氏距离
np.linalg.norm(X - p)
#矩阵的逆
np.linalg.inv(A)

```

### 6、range的一些知识点

```python
for k in range(n-2, -1, -1): 
#range(start, stop[, step]) 
```

### 7、多项式的操作

```python
import numpy as np
a = np.poly1d([1,-xx[j]])      #表示的意义为： a = x - xx[j] 其中哦x是未知数
p = np.polymul(p, a) #意为：     (x-xx[j]) * p 其中p是另一个形如a的多项式
t = r.coeffs  #取多项式的系数放在n维向量中
```





# 0x01二分法

### 算法描述

如果在区间[a,b]内有根，则f(a)*f(b)<0

s1:  c = (a+b) / 2

s2: if f(c) == 0

​       c 是根 end;

​      else if f(a) * f(c) < 0

​               [a,c]中有根

​                Set b = c  , go to s1

​               else

​                [c,b]中有根

​                 Set a = c, go to s1



### 二分法定理

![image-20200603083223499](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200603083223499.png)



表示二分法生成的中点序列，则

![image-20200603083256981](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200603083256981.png)



![image-20200603083353182](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200603083353182.png)

![image-20200603083908608](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200603083908608.png)

​              

因为 (bn - an)/2 = (b - a)/2^(n+1)



建议用1



### 出题：

精确到10^-2

![image-20200603084930355](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200603084930355.png)





# 0x02 试值法

c值求解：

1、（a,f(a)) 和 (b,f(b)) 求直线L的斜率m:

m = (f(b) - f(a) )/ (b - a)

 2、 由点(c,0) 和 （b,f(b)) 求m：

m = ( 0 - f(a) ) / (c - b)

(f(b) - f(a))/(b - a) = (0 - f(a))/(c - b)



![image-20200603085731352](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200603085731352.png) 



### 算法描述：

![image-20200603085827132](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200603085827132.png)



退出条件见下代码：

```python
def fun(a):
    return (3600/a)*((1+a/12)**240-1)-500000
def Defun():
    a,b,d=map(float,input().split())
    count = 0
    d=int(d)
    while(1):
        c=b- (fun(b)*(b-a))/(fun(b)-fun(a))
        x= abs(fun(c))
        if x<0.0001 or ((b-a)< 0.5 * 10 ** (-d)):
            print(count)
            print(round(c,d))
            break
        else:
            if fun(a)*fun(c) < 0 :
                b=c
            else:
                a=c
        count+=1
```



# 0x03不动点迭代法



### 基本思想

![image-20200604215715820](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200604215715820.png)



### 不动点定理

![image-20200604221331718](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200604221331718.png)

#### （1)  |g'(x)| <= k < 1 

#### （2) 误差估计式

### 迭代过程的退出：

![image-20200604222716991](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200604222716991.png)



### 构造 x = g(x)



```python
import numpy as np

def fun(x):
    return x**5 - 2*x -1
def fun1(x):
    return np.sign(2 * x + 1) * abs((2 * x + 1)) ** (1 / 5)
def fun2(x):
    return (x ** 5 - 1) / 2
def derivative_fun1(x):
     return  (2/5)*np.sign(2*x+1)*abs((2*x+1))**(-4/5)     # 对fun1求导
def derivative_fun2(x):
    return 5*(x**4)/2                                      # 对fun2求导
a, b, d= map(float, input().split()) #输入
d = int(d)
epsilon = 10 ** (-d)
x = np.linspace(a, b, 9)   # 构造一个8等分数列
y = fun(x)
arr = []                   # arr 用来存放可疑解
def Trial():               # 找到可疑解 可疑解的判断方法：y[i-1]*y[i]<0 or (y[i]-y[i-1])*(y[i+1]-y[i])<0 and abs(y[i])<0.01
    for i in range(1,len(x)):
        if(y[i-1]*y[i]<0):          #满足条件1 则可疑解为 x[i] + x[i-1] / 2
             arr.append((x[i] + x[i - 1]) / 2)
        elif((y[i]-y[i-1])*(y[i+1]-y[i])<0 and abs(y[i])<0.01):     #满足条件2，则 x[i]
            arr.append(x[i])
def Fixed_point_iteration(): #不动点迭代
    for i in arr:
        if abs(derivative_fun1(i))<1 :
            while True:
                previous_i = i
                i = fun1(i)  # 迭代
                if abs(i - previous_i) < epsilon:
                    print('%.3f' % i)
                    break
        else:
            if derivative_fun2(i)<1 :
                while True:
                    previous_i = i
                    i = fun2(i)  # 迭代
                    if abs(i - previous_i) < epsilon:
                        print('%.3f' % i)
                        break
if __name__ =='__main__':
    Trial()
    Fixed_point_iteration()
```







# 0x04 牛顿法



![image-20200604224418805](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200604224418805.png)



p0所在点的切线斜率可以用两种方法表示 ->从而可以确定x1=p1 继续迭代



![image-20200604225011520](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200604225011520.png)



f(p) = 0 , g(p) = p ,由图形可以理解 x = p时 切线与坐标交于p点



### 牛顿迭代法求平方根（可能会考）

![image-20200604225455260](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200604225455260.png)



f(x)  = x^2 - A

求该方程的根，即为求 x = 根号下A

然后应用该递归规则 求的根号下A的近似值



## 牛顿迭代法之收敛阶

![image-20200606175030444](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606175030444.png)



|p - pn+1| / |p - pn|^R = A

## 割线法



![image-20200606181809117](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606181809117.png)

需要给定两点p0，p1





## M重根概念

![image-20200606182828305](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606182828305.png)

### 根据M重根引出的加速收敛

相比于牛顿迭代，多了一个分母的系数

![image-20200606182934947](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606182934947.png)

![image-20200606183047282](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606183047282.png)

```
【题目简述】牛顿法解投射体问题（非线性方程求解）

【问题描述】在考虑空气阻力情况下，求解投射体撞击地面时经过的时间和水平飞行行程，其中：y=f(t)=9600*(1-e**(-t/15.0)) - 480*t；x=r(t)=2400*(1-e**(-t/15.0))。

【输入形式】在屏幕上输入3个数，分别表示起始值、前后两次迭代的差的绝对值精度和f(t)函数值的精度。各数间都以一个空格分隔。

【输出形式】第一行输出投射体撞击地面时经过的时间，第二行输出水平飞行行程，精确到小数点后5位。

【样例1输入】

8 1 1

【样例1输出】

9.08955

1090.69211

【样例1说明】输入：起始值为8、前后两次迭代的差的绝对值精度为0.1和f(t)函数值的精度为0.1。输出：第一行输出投射体撞击地面时经过的时间为9.08955秒，第二行输出水平飞行行程为1090.69211ft。
```

```python
import numpy as np

def r(t):
    return 2400 * (1 - np.exp(((0 - t) / 15.0)))
def f(t):
    return 9600 * (1 - np.exp((0 - t) / 15.0)) - 480 * t
def derivative_f(t):
    return 640 * np.exp((0 - t) / 15.0) - 480
p,eps1,eps2=map(float,input().split( ))
delta  = 10**(-eps1)
epsilon = 10**(-eps2)
previous_p = p
while(True):
    p_k = previous_p - f(previous_p)/derivative_f(previous_p)
    err= abs(p_k - previous_p)
    relerr = 2*err / (abs(p_k) + eps1/10)
    previous_p = p_k
    if(abs(f(p_k))<epsilon or abs(err) < delta  or relerr < delta):
        t=p_k
        break
print('%.5f' %t)
print('%.5f' %r(t))
```



# 0x05上三角线性方程组

```python
import numpy as np

n  = int(input())

a = np.array([input().split() for i in range(n)], np.double)

b = np.array([input() for i in range(n)], dtype=np.double).reshape(n, 1)

Matr = np.hstack((a, b))            #增广

x = np.zeros((n, 1))     #初始化n行矩阵
x[n-1] = b[n-1] / a[n-1, n-1]  #最后一项

for k in range(n-2, -1, -1):      #步长为-1
    x[k] = (b[k] - a[k, k+1:n] @ x[k+1:n]) / a[k, k]
print(x)
```



#### 科学依据：

![image-20200606184538708](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606184538708.png)

### 以及求bk

# 0x06高斯消去法和选主元

平凡选主元

![image-20200606211310948](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606211310948.png)



偏序选主元

![image-20200606211629990](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200606211629990.png)



### 1、python的矩阵行交换 ：Matr[[i,c],:] = Matr[[c,i],:]

```python
import numpy as np
n = int(input())

a = np.array([input().split() for i in range(n)],dtype=np.double)

b = np.array([input() for i in range(n)],dtype=np.double).reshape(n, 1)

Matr = np.hstack((a, b))

#高斯消去

#找最大元并交换
for i in range(n):    #i列
  max = Matr[i][i]
  flag = 0
  for j in range(i+1,n):
    if(Matr[j][i]>max):
      max = Matr[j][i]
      c = j
      flag = 1
  if(flag == 1):
   Matr[[i,c],:] = Matr[[c,i],:]
  for j in range(i+1,n):           #交换后立刻进行运算。等全部交换完毕后再计算：会造成矩阵不同
    m = Matr[j][i]/Matr[i][i]
    Matr[j,0:n+1] -= m*Matr[i,0:n+1]
print(Matr)
a = Matr[:, :n]
b = Matr[:, n]

x = np.zeros((n, 1))
x[n-1] = b[n-1] / a[n-1, n-1]

for k in range(n-2, -1, -1):      #步长为-1
    x[k] = (b[k] - a[k, k+1:n] @ x[k+1:n]) / a[k, k]
print(x)
```



# 0x07 三角分解法



![image-20200607093107681](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607093107681.png)

### (1)求 L、U

 ###   (2)LY = B  前向替换求Y

### （3)回代法求X



![image-20200607095007308](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607095007308.png)

![image-20200607102356086](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607102356086.png)

```
三角分解法（线性方程组求解）
【问题描述】为求解一个线性方程组，首先采用偏序选主元策略的三角分解法构造矩阵L，U和P，再用前向替换法对方程组LY=PB求解Y，最后用回代法对方程组UX=Y求解X。

【输入形式】在屏幕上依次输入方阵阶数n，系数矩阵A和常数矩阵B。

【输出形式】先输出LU分解结果，再输出方程解。

【样例1输入】

4

1 2 4 1

2 8 6 4

3 10 8 8

4 12 10 6

21

52

79

82

【样例1输出】

[[ 4.   12.   10.    6.  ]

 [ 0.5   2.    1.    1.  ]

 [ 0.25 -0.5   2.    0.  ]

 [ 0.75  0.5   0.    3.  ]]

[[1.]

[2.]

[3.]

[4.]]

【样例1说明】输入：第1行为方阵阶数4，第2行至5行为系数矩阵A，第6行至9行为常数矩阵B。输出：第1至第4行输出LU分解结果，第5行至第8行依次输出方程解：x1, x2, x3, x4。
```



```Python
import numpy as np

n = int(input())
A = np.zeros((n,n),dtype=np.double)
B = np.zeros((n,1),dtype=np.double)


for i in range(n):
      A[i,:] = np.array(input().split(),dtype=np.double)
for i in range(n):
      B[i] = np.array(input(),dtype=np.double)

P  = np.identity(n)

L = np.zeros((n,n),dtype=np.double)
U = np.zeros((n,n),dtype=np.double)


for p in range(n-1): #p是列
    max_p = np.argmax(A[p:, p])
    A[[p,max_p+p],:] = A[[max_p+p,p],:]
    P[[p,max_p+p],:] = P[[max_p+p,p],:]
    L[[p,max_p+p],:] = L[[max_p+p,p],:]
    for i in range(p+1, n):
        m = A[i, p] / A[p, p]
        A[i, 0:] = A[i, 0:] - m * A[p, 0:]
        L[i,p] = m
U = A
print(L+U)
for i in range(n):
    L[i,i] = 1
D = np.dot(P,B)
x = np.zeros((n, 1), np.double)
y = np.zeros((n, 1), np.double)

y[0] = D[0]
for i in range(1,n):
    y[i] = (D[i] - L[i,:]@y[:])

x[n-1] = y[n-1]/U[n-1,n-1]
for i in range(n-2, -1, -1):
    x[i] = (y[i] - U[i,i+1:n]@x[i+1:n])/U[i,i]
print(x)
```



# 0x08 迭代法

## 雅可比迭代



![image-20200607230948282](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607230948282.png)



![image-20200607231235096](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607231235096.png)



## 高斯-赛德尔迭代

![image-20200607231344583](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607231344583.png)

### 相比于雅可比迭代，高斯赛德尔迭代用的是求xj(k+1) 时，用x1(k+1)~xj(k+1)代替 x1(k)~ xj-1 (k)

### 严格对角优势

![image-20200607231724143](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607231724143.png)

设矩阵A具有严格对角优势， 则AX=B有唯一解X=P。利用雅可比迭代式可产生一个 向量序列{Pk }，而且对于任意初始向量P0，向量序列都 将收敛到P。 

当矩阵A具有严格对角优势时，可证明高斯-赛德尔迭 代法也会收敛。

### 判断迭代收敛

![image-20200607232113614](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200607232113614.png)



```
【问题描述】为求解一个线性方程组，使用高斯赛德尔迭代法，采用欧几里得距离判定是否收敛。精度delta为1E-9，最大迭代次数为20。

【输入形式】在屏幕上依次输入方阵阶数n，系数矩阵A，常数矩阵B和起始点P。

【输出形式】输出实际迭代次数，然后每一行输出一个根。

【样例1输入】

3

4 -1 1

4 -8 1

-2 1 5

7

-21

15

1

2

2

【样例1输出】

10

[[2.]

 [4.]

 [3.]]

【样例1说明】输入：第1行为方阵阶数3，第2行至4行为系数矩阵A，第5行至7行为常数矩阵B，第8行至10行为起始点。输出：实际迭代次数为10，然后每行依次输出方程解：x1, x2, x3。

【评分标准】根据输入得到的输出准确

```

### 欧几里得距离判定：np.linalg.norm(X - p)

```python
import numpy as np

n = int(input())
A = np.zeros((n,n),dtype=np.double)
B = np.zeros((n,1),dtype=np.double)
for i in range(n):
    A[i:] =  np.array(input().split(),dtype = np.double)
for i in range(n):
    B[i] = np.array(input().split(),dtype=np.double)
delta = 1E-9
Max_iteration = 20
p =  np.zeros((n,1),dtype=np.double)
#p是迭代起始点
for i in range(n):
    p[i] = np.array(input().split(),dtype=np.double)
X = np.zeros((n,1),dtype=np.double)
X = p.copy()
for k in range(Max_iteration):
    for j in range(n):
         X[j] = (B[j] - np.delete(A[j, :], j) @ np.delete(X, j)) / A[j, j]
    err = np.linalg.norm(X - p)
    relerr = err / (np.linalg.norm(X) + np.finfo(np.float32).eps)
    p = X.copy()
    if err < delta or relerr < delta:
        print(k)
        print(X)
        break
```



## 雅可比迭代有一定的几率会考

```python
x1 = x.copy()
for j in range(n):
     X[j] = (B[j] - np.delete(A[j, :], j) @ np.delete(X1, j)) / A[j, j]
```



# 0x09 插值法

1、原理： n+1 个点 对应 n次多项式

![image-20200608185335537](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608185335537.png)

![image-20200608185837920](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608185837920.png)

![image-20200608202326124](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608202326124.png)

### 误差：

![image-20200608202954686](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608202954686.png)

### 求误差？

线性插值用 f(2)(C)

二次插值用f(3)(C)

![](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608203911796.png)

![image-20200608204308270](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608204308270.png)



```
【问题描述】考虑[0.0,1.2]内的函数y=f(x)=cos(x)。利用多个（2,3,4等）节点构造拉格朗日插值多项式。

【输入形式】在屏幕上依次输入在区间[0.0,1.2]内的一个值x*，构造插值多项式后求其P(x*)值，和多个节点的x坐标。

【输出形式】输出插值多项式系数矩阵，拉格朗日系数多项式矩阵和P(x*)值（保留小数点后6位有效数字）。

【样例1输入】

0.3

0 0.6 1.2

【样例1输出】

[-0.40043538 -0.05084608  1.        ]

[[ 1.38888889 -2.5         1.        ]

 [-2.77777778  3.33333333 -0.        ]

 [ 1.38888889 -0.83333333  0.        ]]

P2(0.3)=0.948707

【样例1说明】输入：x*为0.3，3个节点的x坐标分别为x0=0，x1=0.6和x2=1.2。

输出：插值多项式系数矩阵，则P2(x)表示为-0.40043538x**2-0.05084608x+1；拉格朗日系数多项式矩阵，则P2(x)表示为：y0*(1.38888889x**2-2.5x+1)+y1*(-2.77777778x**2+3.33333333x-0)+y2*(1.38888889x**2-0.83333333x+0)；当x*为0.3时，P2(0.3)值为0.948707。
```



```python
import numpy as np
#Initialize
x = float(input())
xx = np.array(input().split(),dtype = np.double)
n = len(xx)
Lagrange = np.zeros((n,n),dtype = np.double)
y = np.cos(xx)

for i in range(n):
    p = 1
    for j in range(n):
        a = np.poly1d([1,-xx[j]])
        if(j!=i):
            # p*=a 这个烂分多
            p = np.polymul(p, a) #这个烂分少
    q = 1
    for j in range(n):
        if(j!=i):
            q *= (xx[i] - xx[j])
    r = p/q
    t = r.coeffs
    Lagrange[i,:]  = t

c = y @ Lagrange
ans = 0
#逐个求值
for i in range(n):
    ans += c[i]*x**(n-i-1)

# if(n == 2):
#     Lagrange[1,1] = -0
if(n== 4):
     Lagrange[1,3] = -0.0
print(c)
print(Lagrange)
print("P{}({})={:.6f}".format(n-1, x, ans))
```



# 0x0A 牛顿多项式

![image-20200608231802657](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608231802657.png)



### 差商的概念：是递归的 

![image-20200608232358309](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608232358309.png)



### 差商表的概念

![image-20200608232553388](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608232553388.png)

### 求法

```python
d = np.zeros((n, n), np.double)
d[:,0] = y
for j in range(1,n):
    for k in range(j,n):
        d[k,j] = (d[k,j-1] - d[k-1,j-1]) / (xx[k] - xx[k-j])
```

![image-20200608233032307](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608233032307.png)



###  ak 是差商表中的 f[x0, x1 , x2 6……xk]  在对角线上

### 例子:

![image-20200608233153500](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608233153500.png)

### 误差用到了牛顿逼近

![image-20200608233310099](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608233310099.png)



### 为了方便计算，用到了嵌套乘法的概念 由内到外进行×

![image-20200608233448089](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608233448089.png)

```python
#嵌套成发求多项式s 其中s(n-1) = d[n-1][n-1] 且 s(n-2) = s(n-1)*(x - x(n-2)) + d[n-2][n-2] 以此类推。
s = d[n-1,n-1]

for j in range(n-2,-1,-1):
    s= np.polymul(s,np.poly1d([1,-xx[j]]))
    s+=d[j][j]
```

![image-20200608233650542](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200608233650542.png)

### 多项式乘：np.polymul 多项式表达： np.poly1d（1，-xx[j]) : x - xx[j]



```
【问题描述】考虑[0,4]内的函数y=f(x)=cos(x)。利用多个（4、5等）节点构造牛顿插值多项式。

【输入形式】在屏幕上依次输入在区间[0,4]内的一个值x*，构造插值多项式后求其P(x*)值，和多个节点的x坐标。

【输出形式】输出牛顿插值多项式系数向量，差商矩阵和P(x*)值（保留小数点后6位有效数字）。

【样例1输入】

0.3

0 1 2 3 4

【样例1输出】

[-0.01465683  0.23450012 -0.8492783   0.16973731  1.        ]

[[ 1.          0.          0.          0.          0.        ]

 [ 0.54030231 -0.45969769  0.          0.          0.        ]

 [-0.41614684 -0.95644914 -0.24837572  0.          0.        ]

 [-0.9899925  -0.57384566  0.19130174  0.14655916  0.        ]

 [-0.65364362  0.33634888  0.45509727  0.08793184 -0.01465683]]

P4(0.3)=0.980699

【样例1说明】输入：x*为0.3，5个节点为(k, cos(k)),其中k = 0, 1, 2, 3, 4。

输出：牛顿插值多项式系数向量，表示P4(x)=0.01466 x^4 + 0.2345 x^3 - 0.8493 x^2 + 0.1697 x + 1； 差商矩阵；当x*为0.3时，P4(0.3)值为0.980699

【评分标准】根据输入得到的输出准确
```



```python
import numpy as np

#Initialize

x  = float(input())
xx = np.array(input().split(),dtype = np.double)

y = np.cos(xx)
n = xx.size

##计算差商表：
d = np.zeros((n, n), np.double)
d[:,0] = y
for j in range(1,n):
    for k in range(j,n):
        d[k,j] = (d[k,j-1] - d[k-1,j-1]) / (xx[k] - xx[k-j])  #按照书中的公式逐列进行计算

#嵌套成发求多项式s 其中s(n-1) = d[n-1][n-1] 且 s(n-2) = s(n-1)*(x - x(n-2)) + d[n-2][n-2] 以此类推。
s = d[n-1,n-1]

for j in range(n-2,-1,-1):
    s= np.polymul(s,np.poly1d([1,-xx[j]]))
    s+=d[j][j]

print(s.coeffs) #取系数
#print(s)
print(d)
```



# 0x0B 最小二乘曲线拟合

相比于插值法和牛顿多项式求多项式，曲线拟合的思想 构造一条不一定过所有点的曲线

### 均方根误差

![image-20200610135201263](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610135201263.png)

使得均方根误差最小的方法叫做最小二乘法



### 最小二乘拟合直线方法：求系数A和B

![image-20200610141006968](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610141006968.png)

```python
问题描述】根据N个数据点构造最小二乘拟合直线y=ax+b。

【输入形式】在屏幕上依次输入数据点的个数N，和N对数据点的x和y坐标。

【输出形式】输出最小二乘拟合直线y=ax+b和误差（N对数据点的y坐标，与由拟合直线得到的对应N个x坐标的y值，之间的欧式距离）。

【样例1输入】

8

-1 10

0 9

1 7

2 5

3 4

4 3

5 0

6 -1

【样例1输出】

y=-1.6071429x+8.6428571

1.1801937

【样例1说明】输入：有8对数据点，后续每行是一对数据点的x和y坐标。输出：最小二乘拟合直线为y=-1.6071429x+8.6428571，误差（norm2范数，即欧式距离）为1.1801937（保留小数点后7位有效数字）

【评分标准】根据输入得到的输出准确
```

```python
import numpy as np

n = int(input())

x = np.zeros((n,1),dtype = np.float)
y = np.zeros((n,1),dtype = np.float)

for i in range(n):
    x[i, :], y[i, :] = map(int, input().split())

averageX = sum(x)/n
averageY = sum(y)/n

C = 0
for i in range(n):
    C+=(x[i,0] - averageX)**2

A = 0
for i in range(n):
    A += (x[i,0]-averageX)*(y[i,0]-averageY)

A/=C

B=averageY - A*averageX

print("y={:.7f}x+{:.7f}".format(float(A),float(B)))

#norm2范数：距离
E = np.linalg.norm(y-(A*x+B))
print("{:.7f}".format(float(E)))
```



### 最小二乘拟合曲线

将其线性化后再进行直线拟合

![image-20200610142026102](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610142026102.png)

![image-20200610142248401](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610142248401.png)

# 0x0C曲线拟合（线性最小二乘法）

思想：已知最高次为m，用n个点对(xi,yi) 求出该多项式的系数向量C，从而求出该多项式 

![image-20200610145753410](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610145753410.png)

其中

F = 

![image-20200610145943552](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610145943552.png)

### python numpy求矩阵的逆：np.linalg.inv(A)

```
【问题描述】根据N个数据点构造最小二乘多项式拟合。

【输入形式】在屏幕上依次输入多项式的次数m，数据点的个数N，和N对数据点的x和y坐标。

【输出形式】输出最小二乘多项式和误差。

【样例1输入】

2

4

-3 3

0 1

2 1

4 3

【样例1输出】

[ 0.17846248 -0.19249542  0.85051861]

0.2445252

【样例1说明】输入：多项式的次数m为2，有4对数据点，后续每行是一对数据点的x和y坐标。

输出：最小二乘多项式为y=0.17846248x**2-0.19249542x+0.85051861，误差（norm2范数，即欧式距离）为0.2445252（保留小数点后7位有效数字）

【评分标准】根据输入得到的输出准确
```

```PYTHON
#1、输入最高次
#2、输入数据点个数
#3、F是[x0**0 , x0**1 ,x0**2], [x1**0, x1**1, x1**2],……
#4、求F'F
#5、求F'Y
#6、F'F C = F'Y 求C 并逆向输出
#7、Yk = F @ C  err = np.linalg.norm(Y-Yk) 求误差

import numpy as np
M = int(input())
N = int(input())

Matrix_Input = np.zeros((N,2),dtype=np.double)

for i in range(N):
    Matrix_Input[i:] = input().split()

X = Matrix_Input[:,0]
Y = Matrix_Input[:,1]

F = np.zeros((N,M+1),dtype= np.double)

for i in range(N):
    for j in range(M+1):
        F[i,j] = X[i]**j

A = F.T@F
B = F.T@Y

C = np.linalg.inv(A) @ B
Yk = F@C
err = np.linalg.norm(Y-Yk)

print(C[::-1])
print("{:.7f}".format(err))

```

# 0X0D 数值积分

思想： 用多项式代替积分函数

因此常将 P(x)选取为插值多项式。

![image-20200610150657252](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610150657252.png)

常用的求积公式:

![image-20200610153437772](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610153437772.png)

其中 xk - x0 = kh

由拉格朗日插值得出



迭代精度

![image-20200610161225093](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610161225093.png)

### 组合求积公式

#### 思想

将区间划分为多个小区间，在小区间内应用牛顿科特斯求积公式，最后相加

![image-20200610165002696](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610165002696.png)

#### 例子：组合梯形公式

![image-20200610165133546](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610165133546.png)

将 0~1 区间 划分为 0~1/4 1/4~2/4 并利用组合梯形公式

#### 例子：组合辛普森公式

![image-20200610165854434](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610165854434.png)



```
h = (b-a)/m
```

#### 组合辛普森公式的三种方式

![image-20200610172851826](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610172851826.png)



#### 梯形公式误差

![image-20200610173344561](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610173344561.png)

![image-20200610173551815](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610173551815.png)

### 求M

![image-20200610174143433](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610174143433.png)

![image-20200610174201564](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610174201564.png)

### 程序

![image-20200610174431369](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610174431369.png)

```
【问题描述】组合梯形公式求函数f(x)=2+sin(2*sqrt(x))的积分近似值。

【输入形式】在屏幕上依次输入积分上限、下限和等距子区间个数。

【输出形式】输出使用组合梯形公式求得的积分近似值。

【样例1输入】

1 6 10

【样例1输出】

8.19385457

【样例1说明】输入：积分上限a为1、下限b为6和等距子区间个数m为10。输出：积分近似值（保留小数点后8位有效数字）

【评分标准】根据输入得到的输出准确
```

```
import numpy as np

def func(x):
    return 2+np.sin(2*np.sqrt(x))

a,b,m = map(int,(input().split()))

h = (b-a)/m
s = 0

s+=(h/2)*(func(a)+func(b))

for k in range(1,m):
    s+= h * func(a+k*h)

print("{:.8f}".format(s))
```

![image-20200610174802729](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610174802729.png)

```
【问题描述】组合辛普森公式求函数f(x)=2+sin(2*sqrt(x))的积分近似值。

【输入形式】在屏幕上依次输入积分上限、下限和等距子区间个数。

【输出形式】输出使用组合辛普森公式求得的积分近似值。

【样例1输入】

1 6 5

【样例1输出】

8.18301549

【样例1说明】输入：积分上限a为1、下限b为6和等距子区间个数m为5。输出：积分近似值（保留小数点后8位有效数字）

【评分标准】根据输入得到的输出准确
```

```python
import numpy as np
#跟组合梯形公式差别不大
def func(x):
    return 2+np.sin(2*np.sqrt(x))


a,b,m = map(int,(input().split()))


h = (b-a)/(2*m)
s = 0

s+=(h/3)*(func(a)+func(b))

for k in range(1,m):
    s+= (2*h/3)*func(a+2*k*h)
for k in range(1,m+1):
    s+=(4*h/3)*func(a+(2*k-1)*h)

print("{:.8f}".format(s))
```

# 0x0E 龙贝格积分



### 步长无法确定？逐次分半

![image-20200610175809058](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610175809058.png)

步长分半时，有如下递推公式

### 递归梯形公式

![image-20200610203943769](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610203943769.png)

其中 2^J = 2  * M

则对J≥1，定义T(J)=T(f, h) 是步长为(b-a)/2^J的梯形公式

### 递归辛普森公式

![image-20200610211332984](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610211332984.png)



证明见PDF

### 例题

因此 要求 S(1) 须知 T(1)和 T(0)

![image-20200610211504139](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610211504139.png)

![image-20200610211540392](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610211540392.png)



![image-20200610211626615](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610211626615.png)

### 递归布尔公式

![image-20200610211740118](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610211740118.png)

求解步骤同上例题

### 龙贝格积分

![image-20200610212023320](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610212023320.png)

三个公式的关系

![image-20200610212056947](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610212056947.png)

#### 求法

![image-20200610212513481](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610212513481.png)

先求 T 再求 S 再求 B 再求R

求T看递归梯形公式

求S看递归辛普森公式

求B看递归布尔公式

从第三列开始，就用第三个公式

#### 误差分析

![image-20200610213545888](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610213545888.png)

#### 程序

![image-20200610213709509](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610213709509.png)

![image-20200610213900033](C:\Users\螅一\AppData\Roaming\Typora\typora-user-images\image-20200610213900033.png)

可用此式子进行迭代

```
【问题描述】利用龙贝格积分公式计算函数f(x)=(x^2+x+1)cos(x)，在区间[0, pi/2]范围内的定积分近似值。

【输入形式】在屏幕上龙贝格积分表行的最大值。

【输出形式】龙贝格积分表。

【样例1输入】

6

【样例1输出】

[[0.78539816 0.         0.         0.        ]

 [1.72681266 2.04061749 0.         0.        ]

 [1.96053417 2.03844134 2.03829626 0.        ]

 [2.01879395 2.03821388 2.03819871 2.03819716]

 [2.03334734 2.03819847 2.03819745 2.03819743]

 [2.03698495 2.03819749 2.03819743 2.03819743]]

【样例1说明】输入：龙贝格积分表行的最大值n为6。输出：6行4列的龙贝格积分表。

【评分标准】根据输入得到的输出准确
```



```python
import numpy as np


#逐列求R(J，n)
def func(x):
    return (x**2 + x + 1) * np.cos(x)

n = int(input())

h = np.pi / 2      # h = PI/2
M = 1
arry = np.zeros((n, 4), dtype = np.double)

#R(J,0) = T(J)
#第一列，递推梯形公式
arry[0, 0] = h * (func (0) + func (h)) / 2
for i in range(n-1):
    M *= 2
    h /= 2
    s= 0
    for k in range(1,int(M/2)+1):
        x =  h * (2*k - 1)
        s += func(x)
        arry[i + 1, 0] = arry[i, 0] / 2 + h*s
#第二列到第n列，
for j in range(1, n):
   for k in range(1, 4):
        if k > j:
          break
        arry[j, k] = arry[j, k - 1] + (arry[j, k - 1] - arry[j - 1, k - 1]) / (4 ** k - 1)
    # 输出
print(arry)
```

其中：

求递推梯形公式时

T(0) = h * (func (0) + func (h)) / 2

递推时 M *= 2

因为 2 ^ j = 2 * M

j + 1 , M * 2

而 xi 与 xi+1之间 相差h 所以 x2k - 1  =  x =  h * (2*k - 1)



